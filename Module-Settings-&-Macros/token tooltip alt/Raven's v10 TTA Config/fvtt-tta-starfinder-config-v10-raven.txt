{
  "gmSettings": {
    "default": {
      "items": [
        {
          "disposition": "FRIENDLY",
          "items": [
            {
              "value": "{ sp=<attributes.sp.value>; spm=<attributes.sp.max>; concat(string(sp), \"/\", string(spm), \" Stamina\") }",
              "icon": "fa-bolt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ rp=<attributes.rp.value>; rpm=<attributes.rp.max>; concat(string(rp), \"/\", string(rpm), \" Resolve\") }",
              "icon": "fa-user-plus",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#eaed07"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "NEUTRAL",
          "items": [
            {
              "value": "{ sp=<attributes.sp.value>; spm=<attributes.sp.max>; concat(string(sp), \"/\", string(spm), \" Stamina\") }",
              "icon": "fa-bolt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ rp=<attributes.rp.value>; rpm=<attributes.rp.max>; concat(string(rp), \"/\", string(rpm), \" Resolve\") }",
              "icon": "fa-user-plus",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#eaed07"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "HOSTILE",
          "items": [
            {
              "value": "{ sp=<attributes.sp.value>; spm=<attributes.sp.max>; concat(string(sp), \"/\", string(spm), \" Stamina\") }",
              "icon": "fa-bolt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ rp=<attributes.rp.value>; rpm=<attributes.rp.max>; concat(string(rp), \"/\", string(rpm), \" Resolve\") }",
              "icon": "fa-user-plus",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#eaed07"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        }
      ],
      "static": {
        "displayNameInTooltip": true,
        "useAccentEverywhere": false,
        "accentColor": "#2a65b6",
        "tokenDispositions": [
          "FRIENDLY",
          "NEUTRAL",
          "HOSTILE"
        ],
        "useAccentColorForEverything": false
      }
    },
    "character": {
      "items": [
        {
          "disposition": "FRIENDLY",
          "items": [
            {
              "value": "{ sp=<attributes.sp.value>; spm=<attributes.sp.max>; concat(string(sp), \"/\", string(spm), \" Stamina\") }",
              "icon": "fa-bolt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ rp=<attributes.rp.value>; rpm=<attributes.rp.max>; concat(string(rp), \"/\", string(rpm), \" Resolve\") }",
              "icon": "fa-user-plus",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#eaed07"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "NEUTRAL",
          "items": [
            {
              "value": "{ sp=<attributes.sp.value>; spm=<attributes.sp.max>; concat(string(sp), \"/\", string(spm), \" Stamina\") }",
              "icon": "fa-bolt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ rp=<attributes.rp.value>; rpm=<attributes.rp.max>; concat(string(rp), \"/\", string(rpm), \" Resolve\") }",
              "icon": "fa-user-plus",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#eaed07"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "HOSTILE",
          "items": [
            {
              "value": "{ sp=<attributes.sp.value>; spm=<attributes.sp.max>; concat(string(sp), \"/\", string(spm), \" Stamina\") }",
              "icon": "fa-bolt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ rp=<attributes.rp.value>; rpm=<attributes.rp.max>; concat(string(rp), \"/\", string(rpm), \" Resolve\") }",
              "icon": "fa-user-plus",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#eaed07"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        }
      ],
      "static": {
        "displayNameInTooltip": true,
        "useAccentEverywhere": false,
        "accentColor": "#2a65b6",
        "tokenDispositions": [
          "FRIENDLY",
          "NEUTRAL",
          "HOSTILE"
        ],
        "useAccentColorForEverything": false
      }
    },
    "drone": {
      "items": [
        {
          "disposition": "FRIENDLY",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "NEUTRAL",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "HOSTILE",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        }
      ],
      "static": {
        "displayNameInTooltip": true,
        "useAccentEverywhere": false,
        "accentColor": "#646464",
        "tokenDispositions": [
          "FRIENDLY",
          "NEUTRAL",
          "HOSTILE"
        ],
        "useAccentColorForEverything": false
      }
    },
    "npc": {
      "items": [
        {
          "disposition": "FRIENDLY",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ rp=<attributes.rp.value>; rpm=<attributes.rp.max>; concat(string(rp), \"/\", string(rpm), \" Resolve\") }",
              "icon": "fa-user-plus",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#eaed07"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "NEUTRAL",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ rp=<attributes.rp.value>; rpm=<attributes.rp.max>; concat(string(rp), \"/\", string(rpm), \" Resolve\") }",
              "icon": "fa-user-plus",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#eaed07"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "HOSTILE",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ rp=<attributes.rp.value>; rpm=<attributes.rp.max>; concat(string(rp), \"/\", string(rpm), \" Resolve\") }",
              "icon": "fa-user-plus",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#eaed07"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        }
      ],
      "static": {
        "displayNameInTooltip": true,
        "useAccentEverywhere": false,
        "accentColor": "#2a65b6",
        "tokenDispositions": [
          "FRIENDLY",
          "NEUTRAL",
          "HOSTILE"
        ],
        "useAccentColorForEverything": false
      }
    },
    "npc2": {
      "items": [
        {
          "disposition": "FRIENDLY",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ rp=<attributes.rp.value>; rpm=<attributes.rp.max>; concat(string(rp), \"/\", string(rpm), \" Resolve\") }",
              "icon": "fa-user-plus",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#eaed07"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "NEUTRAL",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ rp=<attributes.rp.value>; rpm=<attributes.rp.max>; concat(string(rp), \"/\", string(rpm), \" Resolve\") }",
              "icon": "fa-user-plus",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#eaed07"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "HOSTILE",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ rp=<attributes.rp.value>; rpm=<attributes.rp.max>; concat(string(rp), \"/\", string(rpm), \" Resolve\") }",
              "icon": "fa-user-plus",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#eaed07"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        }
      ],
      "static": {
        "displayNameInTooltip": true,
        "useAccentEverywhere": false,
        "accentColor": "#2a65b6",
        "tokenDispositions": [
          "FRIENDLY",
          "NEUTRAL",
          "HOSTILE"
        ],
        "useAccentColorForEverything": false
      }
    },
    "hazard": {
      "items": [
        {
          "disposition": "FRIENDLY",
          "items": []
        },
        {
          "disposition": "NEUTRAL",
          "items": []
        },
        {
          "disposition": "HOSTILE",
          "items": []
        }
      ],
      "static": {
        "displayNameInTooltip": true,
        "accentColor": "#cfcef3",
        "useAccentColorForEverything": false,
        "tokenDispositions": [
          "FRIENDLY",
          "NEUTRAL",
          "HOSTILE"
        ]
      }
    },
    "starship": {
      "items": [
        {
          "disposition": "FRIENDLY",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Hull\") }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ ct=<attributes.criticalThreshold.value>; dt=<attributes.damageThreshold.value>; concat(string(ct), \" CT  \", string(dt), \" DT\") }",
              "icon": "fa-fire-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ speed=<attributes.speed.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-rocket",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "attributes.maneuverability",
              "icon": "fa-directions",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "{ tier=<details.tier>; concat(string(tier), \" Tier (\", string(floor(1.5 * tier)), \")\") }",
              "icon": "fa-layer-group",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "{ shield=<quadrants.forward.shields.value>; ac=<quadrants.forward.ac.value>; tl=<quadrants.forward.targetLock.value>; concat(string(shield), \" S, \", string(ac), \" AC, \", string(tl), \" TL\") }",
              "icon": "fa-angle-double-up",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.port.shields.value>; ac=<quadrants.port.ac.value>; tl=<quadrants.port.targetLock.value>; concat(string(shield), \" S, \", string(ac), \" AC, \", string(tl), \" TL\") }",
              "icon": "fa-angle-double-left",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.starboard.shields.value>; ac=<quadrants.starboard.ac.value>; tl=<quadrants.starboard.targetLock.value>; concat(string(shield), \" S, \", string(ac), \" AC, \", string(tl), \" TL\") }",
              "icon": "fa-angle-double-right",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.aft.shields.value>; ac=<quadrants.aft.ac.value>; tl=<quadrants.aft.targetLock.value>; concat(string(shield), \" S, \", string(ac), \" AC, \", string(tl), \" TL\") }",
              "icon": "fa-angle-double-down",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            }
          ]
        },
        {
          "disposition": "NEUTRAL",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Hull\") }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ ct=<attributes.criticalThreshold.value>; dt=<attributes.damageThreshold.value>; concat(string(ct), \" CT  \", string(dt), \" DT\") }",
              "icon": "fa-fire-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ speed=<attributes.speed.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-rocket",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "attributes.maneuverability",
              "icon": "fa-directions",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "{ tier=<details.tier>; concat(string(tier), \" Tier (\", string(floor(1.5 * tier)), \")\") }",
              "icon": "fa-layer-group",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "{ shield=<quadrants.forward.shields.value>; ac=<quadrants.forward.ac.value>; tl=<quadrants.forward.targetLock.value>; concat(string(shield), \" S, \", string(ac), \" AC, \", string(tl), \" TL\") }",
              "icon": "fa-angle-double-up",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.port.shields.value>; ac=<quadrants.port.ac.value>; tl=<quadrants.port.targetLock.value>; concat(string(shield), \" S, \", string(ac), \" AC, \", string(tl), \" TL\") }",
              "icon": "fa-angle-double-left",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.starboard.shields.value>; ac=<quadrants.starboard.ac.value>; tl=<quadrants.starboard.targetLock.value>; concat(string(shield), \" S, \", string(ac), \" AC, \", string(tl), \" TL\") }",
              "icon": "fa-angle-double-right",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.aft.shields.value>; ac=<quadrants.aft.ac.value>; tl=<quadrants.aft.targetLock.value>; concat(string(shield), \" S, \", string(ac), \" AC, \", string(tl), \" TL\") }",
              "icon": "fa-angle-double-down",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            }
          ]
        },
        {
          "disposition": "HOSTILE",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Hull\") }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ ct=<attributes.criticalThreshold.value>; dt=<attributes.damageThreshold.value>; concat(string(ct), \" CT  \", string(dt), \" DT\") }",
              "icon": "fa-fire-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ speed=<attributes.speed.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-rocket",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "attributes.maneuverability",
              "icon": "fa-directions",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "{ tier=<details.tier>; concat(string(tier), \" Tier (\", string(floor(1.5 * tier)), \")\") }",
              "icon": "fa-layer-group",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "{ shield=<quadrants.forward.shields.value>; ac=<quadrants.forward.ac.value>; tl=<quadrants.forward.targetLock.value>; concat(string(shield), \" S, \", string(ac), \" AC, \", string(tl), \" TL\") }",
              "icon": "fa-angle-double-up",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.port.shields.value>; ac=<quadrants.port.ac.value>; tl=<quadrants.port.targetLock.value>; concat(string(shield), \" S, \", string(ac), \" AC, \", string(tl), \" TL\") }",
              "icon": "fa-angle-double-left",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.starboard.shields.value>; ac=<quadrants.starboard.ac.value>; tl=<quadrants.starboard.targetLock.value>; concat(string(shield), \" S, \", string(ac), \" AC, \", string(tl), \" TL\") }",
              "icon": "fa-angle-double-right",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.aft.shields.value>; ac=<quadrants.aft.ac.value>; tl=<quadrants.aft.targetLock.value>; concat(string(shield), \" S, \", string(ac), \" AC, \", string(tl), \" TL\") }",
              "icon": "fa-angle-double-down",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            }
          ]
        }
      ],
      "static": {
        "displayNameInTooltip": true,
        "useAccentEverywhere": false,
        "accentColor": "#351a51",
        "tokenDispositions": [
          "FRIENDLY",
          "NEUTRAL",
          "HOSTILE"
        ],
        "useAccentColorForEverything": false
      }
    },
    "vehicle": {
      "items": [
        {
          "disposition": "FRIENDLY",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" HP\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ th=<attributes.hp.threshold>; h=<attributes.hardness>; concat(string(h), \" Hard \", string(th), \" THD\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ th=<attributes.hp.threshold>; hp=<attributes.hp.value>; hpm=<attributes.hp.max>;hp <= 0 ? \"Wrecked\" : hp <= th & hpm > 1 ? \"Broken\" : \"Functional\" }",
              "icon": "fa-gears",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#f1c232"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "attributes.cover",
              "icon": "fa-user-shield",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#808080"
            },
            {
              "value": "attributes.speed.drive",
              "icon": "fa-step-forward",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "attributes.speed.full",
              "icon": "fa-fast-forward",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "attributes.speed.mph",
              "icon": "fa-shipping-fast",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "NEUTRAL",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" HP\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ th=<attributes.hp.threshold>; h=<attributes.hardness>; concat(string(h), \" Hard \", string(th), \" THD\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ th=<attributes.hp.threshold>; hp=<attributes.hp.value>; hpm=<attributes.hp.max>;hp <= 0 ? \"Wrecked\" : hp <= th & hpm > 1 ? \"Broken\" : \"Functional\" }",
              "icon": "fa-gears",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#f1c232"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "attributes.cover",
              "icon": "fa-user-shield",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#808080"
            },
            {
              "value": "attributes.speed.drive",
              "icon": "fa-step-forward",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "attributes.speed.full",
              "icon": "fa-fast-forward",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "attributes.speed.mph",
              "icon": "fa-shipping-fast",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "HOSTILE",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" HP\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ th=<attributes.hp.threshold>; h=<attributes.hardness>; concat(string(h), \" Hard \", string(th), \" THD\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ th=<attributes.hp.threshold>; hp=<attributes.hp.value>; hpm=<attributes.hp.max>;hp <= 0 ? \"Wrecked\" : hp <= th & hpm > 1 ? \"Broken\" : \"Functional\" }",
              "icon": "fa-gears",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#f1c232"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "attributes.cover",
              "icon": "fa-user-shield",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#808080"
            },
            {
              "value": "attributes.speed.drive",
              "icon": "fa-step-forward",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "attributes.speed.full",
              "icon": "fa-fast-forward",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "attributes.speed.mph",
              "icon": "fa-shipping-fast",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        }
      ],
      "static": {
        "displayNameInTooltip": true,
        "useAccentEverywhere": false,
        "accentColor": "#351a51",
        "tokenDispositions": [
          "FRIENDLY",
          "NEUTRAL",
          "HOSTILE"
        ],
        "useAccentColorForEverything": false
      }
    }
  },
  "playerSettings": {
    "default": {
      "items": [
        {
          "disposition": "OWNED",
          "items": [
            {
              "value": "{ sp=<attributes.sp.value>; spm=<attributes.sp.max>; concat(string(sp), \"/\", string(spm), \" Stamina\") }",
              "icon": "fa-bolt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ rp=<attributes.rp.value>; rpm=<attributes.rp.max>; concat(string(rp), \"/\", string(rpm), \" Resolve\") }",
              "icon": "fa-user-plus",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#eaed07"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "FRIENDLY",
          "items": [
            {
              "value": "{ sp=<attributes.sp.value>; spm=<attributes.sp.max>; sp <= 0 ? \"❌\" : sp == 1 & spm > 1 ? \"♡♡♡♡\" : sp == 69 ? \"Nice\" : sp < spm*0.25 ? \"❤♡♡♡\" : sp < spm*0.5 ? \"❤❤♡♡\" : sp < spm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-bolt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "NEUTRAL",
          "items": [
            {
              "value": "{ sp=<attributes.sp.value>; spm=<attributes.sp.max>; sp <= 0 ? \"❌\" : sp == 1 & spm > 1 ? \"♡♡♡♡\" : sp == 69 ? \"Nice\" : sp < spm*0.25 ? \"❤♡♡♡\" : sp < spm*0.5 ? \"❤❤♡♡\" : sp < spm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-bolt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "HOSTILE",
          "items": [
            {
              "value": "{ sp=<attributes.sp.value>; spm=<attributes.sp.max>; sp <= 0 ? \"❌\" : sp == 1 & spm > 1 ? \"♡♡♡♡\" : sp == 69 ? \"Nice\" : sp < spm*0.25 ? \"❤♡♡♡\" : sp < spm*0.5 ? \"❤❤♡♡\" : sp < spm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-bolt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        }
      ],
      "static": {
        "displayNameInTooltip": "FRIENDLY",
        "useAccentEverywhere": false,
        "accentColor": "#2a65b6",
        "tokenDispositions": [
          "OWNED",
          "FRIENDLY",
          "NEUTRAL",
          "HOSTILE"
        ],
        "useAccentColorForEverything": false
      }
    },
    "character": {
      "items": [
        {
          "disposition": "OWNED",
          "items": [
            {
              "value": "{ sp=<attributes.sp.value>; spm=<attributes.sp.max>; concat(string(sp), \"/\", string(spm), \" Stamina\") }",
              "icon": "fa-bolt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ rp=<attributes.rp.value>; rpm=<attributes.rp.max>; concat(string(rp), \"/\", string(rpm), \" Resolve\") }",
              "icon": "fa-user-plus",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#eaed07"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "FRIENDLY",
          "items": [
            {
              "value": "{ sp=<attributes.sp.value>; spm=<attributes.sp.max>; sp <= 0 ? \"❌\" : sp == 1 & spm > 1 ? \"♡♡♡♡\" : sp == 69 ? \"Nice\" : sp < spm*0.25 ? \"❤♡♡♡\" : sp < spm*0.5 ? \"❤❤♡♡\" : sp < spm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-bolt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "NEUTRAL",
          "items": [
            {
              "value": "{ sp=<attributes.sp.value>; spm=<attributes.sp.max>; sp <= 0 ? \"❌\" : sp == 1 & spm > 1 ? \"♡♡♡♡\" : sp == 69 ? \"Nice\" : sp < spm*0.25 ? \"❤♡♡♡\" : sp < spm*0.5 ? \"❤❤♡♡\" : sp < spm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-bolt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "HOSTILE",
          "items": [
            {
              "value": "{ sp=<attributes.sp.value>; spm=<attributes.sp.max>; sp <= 0 ? \"❌\" : sp == 1 & spm > 1 ? \"♡♡♡♡\" : sp == 69 ? \"Nice\" : sp < spm*0.25 ? \"❤♡♡♡\" : sp < spm*0.5 ? \"❤❤♡♡\" : sp < spm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-bolt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        }
      ],
      "static": {
        "displayNameInTooltip": "HOSTILE",
        "useAccentEverywhere": false,
        "accentColor": "#2a65b6",
        "tokenDispositions": [
          "OWNED",
          "FRIENDLY",
          "NEUTRAL",
          "HOSTILE"
        ],
        "useAccentColorForEverything": false
      }
    },
    "drone": {
      "items": [
        {
          "disposition": "OWNED",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "FRIENDLY",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "NEUTRAL",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "HOSTILE",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        }
      ],
      "static": {
        "displayNameInTooltip": "HOSTILE",
        "useAccentEverywhere": false,
        "accentColor": "#646464",
        "tokenDispositions": [
          "OWNED",
          "FRIENDLY",
          "NEUTRAL",
          "HOSTILE"
        ],
        "useAccentColorForEverything": false
      }
    },
    "npc": {
      "items": [
        {
          "disposition": "OWNED",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ rp=<attributes.rp.value>; rpm=<attributes.rp.max>; concat(string(rp), \"/\", string(rpm), \" Resolve\") }",
              "icon": "fa-user-plus",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#eaed07"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "FRIENDLY",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "NEUTRAL",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "HOSTILE",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        }
      ],
      "static": {
        "displayNameInTooltip": "HOSTILE",
        "useAccentEverywhere": false,
        "accentColor": "#2a65b6",
        "tokenDispositions": [
          "OWNED",
          "FRIENDLY",
          "NEUTRAL",
          "HOSTILE"
        ],
        "useAccentColorForEverything": false
      }
    },
    "npc2": {
      "items": [
        {
          "disposition": "OWNED",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Health\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC. \", string(kac + 8), \" KAC + 8\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "{ rp=<attributes.rp.value>; rpm=<attributes.rp.max>; concat(string(rp), \"/\", string(rpm), \" Resolve\") }",
              "icon": "fa-user-plus",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#eaed07"
            },
            {
              "value": "{ speed=<attributes.speed.land.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-running",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "FRIENDLY",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "NEUTRAL",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "HOSTILE",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        }
      ],
      "static": {
        "displayNameInTooltip": "HOSTILE",
        "useAccentEverywhere": false,
        "accentColor": "#2a65b6",
        "tokenDispositions": [
          "OWNED",
          "FRIENDLY",
          "NEUTRAL",
          "HOSTILE"
        ],
        "useAccentColorForEverything": false
      }
    },
    "hazard": {
      "items": [
        {
          "disposition": "OWNED",
          "items": []
        },
        {
          "disposition": "FRIENDLY",
          "items": []
        },
        {
          "disposition": "NEUTRAL",
          "items": []
        },
        {
          "disposition": "HOSTILE",
          "items": []
        }
      ],
      "static": {
        "displayNameInTooltip": "FRIENDLY",
        "accentColor": "#159833",
        "useAccentColorForEverything": false,
        "tokenDispositions": [
          "OWNED",
          "FRIENDLY",
          "NEUTRAL",
          "HOSTILE"
        ]
      }
    },
    "starship": {
      "items": [
        {
          "disposition": "OWNED",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" Hull\") }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ ct=<attributes.criticalThreshold.value>; dt=<attributes.damageThreshold.value>; concat(string(ct), \" CT  \", string(dt), \" DT\") }",
              "icon": "fa-fire-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ speed=<attributes.speed.value>; concat(string(speed), \" Speed\") }",
              "icon": "fa-rocket",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "attributes.maneuverability",
              "icon": "fa-directions",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "{ tier=<details.tier>; concat(string(tier), \" Tier (\", string(floor(1.5 * tier)), \")\") }",
              "icon": "fa-layer-group",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "{ shield=<quadrants.forward.shields.value>; ac=<quadrants.forward.ac.value>; tl=<quadrants.forward.targetLock.value>; concat(string(shield), \" S, \", string(ac), \" AC, \", string(tl), \" TL\") }",
              "icon": "fa-angle-double-up",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.port.shields.value>; ac=<quadrants.port.ac.value>; tl=<quadrants.port.targetLock.value>; concat(string(shield), \" S, \", string(ac), \" AC, \", string(tl), \" TL\") }",
              "icon": "fa-angle-double-left",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.starboard.shields.value>; ac=<quadrants.starboard.ac.value>; tl=<quadrants.starboard.targetLock.value>; concat(string(shield), \" S, \", string(ac), \" AC, \", string(tl), \" TL\") }",
              "icon": "fa-angle-double-right",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.aft.shields.value>; ac=<quadrants.aft.ac.value>; tl=<quadrants.aft.targetLock.value>; concat(string(shield), \" S, \", string(ac), \" AC, \", string(tl), \" TL\") }",
              "icon": "fa-angle-double-down",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            }
          ]
        },
        {
          "disposition": "FRIENDLY",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "{ shield=<quadrants.forward.shields.value>; qmax=<attributes.shields.limit>; shield <= 0 ? \"❌\" : shield == 1 & qmax > 1 ? \"♡♡♡♡\" : shield == 69 ? \"Nice\" : shield < qmax*0.25 ? \"❤♡♡♡\" : shield < qmax*0.5 ? \"❤❤♡♡\" : shield < qmax*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-angle-double-up",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.port.shields.value>; qmax=<attributes.shields.limit>; shield <= 0 ? \"❌\" : shield == 1 & qmax > 1 ? \"♡♡♡♡\" : shield == 69 ? \"Nice\" : shield < qmax*0.25 ? \"❤♡♡♡\" : shield < qmax*0.5 ? \"❤❤♡♡\" : shield < qmax*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-angle-double-left",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.starboard.shields.value>; qmax=<attributes.shields.limit>; shield <= 0 ? \"❌\" : shield == 1 & qmax > 1 ? \"♡♡♡♡\" : shield == 69 ? \"Nice\" : shield < qmax*0.25 ? \"❤♡♡♡\" : shield < qmax*0.5 ? \"❤❤♡♡\" : shield < qmax*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-angle-double-right",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.aft.shields.value>; qmax=<attributes.shields.limit>; shield <= 0 ? \"❌\" : shield == 1 & qmax > 1 ? \"♡♡♡♡\" : shield == 69 ? \"Nice\" : shield < qmax*0.25 ? \"❤♡♡♡\" : shield < qmax*0.5 ? \"❤❤♡♡\" : shield < qmax*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-angle-double-down",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            }
          ]
        },
        {
          "disposition": "NEUTRAL",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "{ shield=<quadrants.forward.shields.value>; qmax=<attributes.shields.limit>; shield <= 0 ? \"❌\" : shield == 1 & qmax > 1 ? \"♡♡♡♡\" : shield == 69 ? \"Nice\" : shield < qmax*0.25 ? \"❤♡♡♡\" : shield < qmax*0.5 ? \"❤❤♡♡\" : shield < qmax*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-angle-double-up",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.port.shields.value>; qmax=<attributes.shields.limit>; shield <= 0 ? \"❌\" : shield == 1 & qmax > 1 ? \"♡♡♡♡\" : shield == 69 ? \"Nice\" : shield < qmax*0.25 ? \"❤♡♡♡\" : shield < qmax*0.5 ? \"❤❤♡♡\" : shield < qmax*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-angle-double-left",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.starboard.shields.value>; qmax=<attributes.shields.limit>; shield <= 0 ? \"❌\" : shield == 1 & qmax > 1 ? \"♡♡♡♡\" : shield == 69 ? \"Nice\" : shield < qmax*0.25 ? \"❤♡♡♡\" : shield < qmax*0.5 ? \"❤❤♡♡\" : shield < qmax*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-angle-double-right",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.aft.shields.value>; qmax=<attributes.shields.limit>; shield <= 0 ? \"❌\" : shield == 1 & qmax > 1 ? \"♡♡♡♡\" : shield == 69 ? \"Nice\" : shield < qmax*0.25 ? \"❤♡♡♡\" : shield < qmax*0.5 ? \"❤❤♡♡\" : shield < qmax*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-angle-double-down",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            }
          ]
        },
        {
          "disposition": "HOSTILE",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "{ shield=<quadrants.forward.shields.value>; qmax=<attributes.shields.limit>; shield <= 0 ? \"❌\" : shield == 1 & qmax > 1 ? \"♡♡♡♡\" : shield == 69 ? \"Nice\" : shield < qmax*0.25 ? \"❤♡♡♡\" : shield < qmax*0.5 ? \"❤❤♡♡\" : shield < qmax*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-angle-double-up",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.port.shields.value>; qmax=<attributes.shields.limit>; shield <= 0 ? \"❌\" : shield == 1 & qmax > 1 ? \"♡♡♡♡\" : shield == 69 ? \"Nice\" : shield < qmax*0.25 ? \"❤♡♡♡\" : shield < qmax*0.5 ? \"❤❤♡♡\" : shield < qmax*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-angle-double-left",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.starboard.shields.value>; qmax=<attributes.shields.limit>; shield <= 0 ? \"❌\" : shield == 1 & qmax > 1 ? \"♡♡♡♡\" : shield == 69 ? \"Nice\" : shield < qmax*0.25 ? \"❤♡♡♡\" : shield < qmax*0.5 ? \"❤❤♡♡\" : shield < qmax*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-angle-double-right",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ shield=<quadrants.aft.shields.value>; qmax=<attributes.shields.limit>; shield <= 0 ? \"❌\" : shield == 1 & qmax > 1 ? \"♡♡♡♡\" : shield == 69 ? \"Nice\" : shield < qmax*0.25 ? \"❤♡♡♡\" : shield < qmax*0.5 ? \"❤❤♡♡\" : shield < qmax*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-angle-double-down",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            }
          ]
        }
      ],
      "static": {
        "displayNameInTooltip": "HOSTILE",
        "useAccentEverywhere": false,
        "accentColor": "#351a51",
        "tokenDispositions": [
          "OWNED",
          "FRIENDLY",
          "NEUTRAL",
          "HOSTILE"
        ],
        "useAccentColorForEverything": false
      }
    },
    "vehicle": {
      "items": [
        {
          "disposition": "OWNED",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; concat(string(hp), \"/\", string(hpm), \" HP\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#5dc33d"
            },
            {
              "value": "{ th=<attributes.hp.threshold>; h=<attributes.hardness>; concat(string(h), \" Hard \", string(th), \" THD\") }",
              "icon": "fa-heartbeat",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#678abf"
            },
            {
              "value": "{ th=<attributes.hp.threshold>; hp=<attributes.hp.value>; hpm=<attributes.hp.max>;hp <= 0 ? \"Wrecked\" : hp <= th & hpm > 1 ? \"Broken\" : \"Functional\" }",
              "icon": "fa-gears",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#f1c232"
            },
            {
              "value": "{ kac=<attributes.kac.value>; concat(string(kac), \" KAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d1333b"
            },
            {
              "value": "{ eac=<attributes.eac.value>; concat(string(eac), \" EAC\") }",
              "icon": "fa-shield-alt",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#4a43cb"
            },
            {
              "value": "attributes.cover",
              "icon": "fa-user-shield",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#808080"
            },
            {
              "value": "attributes.speed.drive",
              "icon": "fa-step-forward",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "attributes.speed.full",
              "icon": "fa-fast-forward",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "attributes.speed.mph",
              "icon": "fa-shipping-fast",
              "isFunction": false,
              "expression": false,
              "isNumber": false,
              "color": "#ffffff"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "FRIENDLY",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "{ th=<attributes.hp.threshold>; hp=<attributes.hp.value>; hpm=<attributes.hp.max>;hp <= 0 ? \"Wrecked\" : hp <= th & hpm > 1 ? \"Broken\" : \"Functional\" }",
              "icon": "fa-gears",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#f1c232"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "NEUTRAL",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "{ th=<attributes.hp.threshold>; hp=<attributes.hp.value>; hpm=<attributes.hp.max>;hp <= 0 ? \"Wrecked\" : hp <= th & hpm > 1 ? \"Broken\" : \"Functional\" }",
              "icon": "fa-gears",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#f1c232"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        },
        {
          "disposition": "HOSTILE",
          "items": [
            {
              "value": "{ hp=<attributes.hp.value>; hpm=<attributes.hp.max>; hp <= 0 ? \"❌\" : hp == 1 & hpm > 1 ? \"♡♡♡♡\" : hp == 69 ? \"Nice\" : hp < hpm*0.25 ? \"❤♡♡♡\" : hp < hpm*0.5 ? \"❤❤♡♡\" : hp < hpm*0.75 ? \"❤❤❤♡\" : \"❤❤❤❤\" }",
              "icon": "fa-heart",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#d31d1d"
            },
            {
              "value": "{ th=<attributes.hp.threshold>; hp=<attributes.hp.value>; hpm=<attributes.hp.max>;hp <= 0 ? \"Wrecked\" : hp <= th & hpm > 1 ? \"Broken\" : \"Functional\" }",
              "icon": "fa-gears",
              "isFunction": false,
              "expression": true,
              "isNumber": false,
              "color": "#f1c232"
            },
            {
              "value": "let distance = tokenDistance(_token, token);\nreturn \"~\" +Math.ceil(distance) +\" ft\";\n/*\n  Total Distance between two tokens.\n*/\nfunction tokenDistance(token1, token2)\n{\n  if(!token1 || !token2) return;\n\n  let distance = measureDistancePF2(token1, token2);\n  if(token1.elevation !== token2.data.elevation)\n  {\n    let h_diff = token2.data.elevation > token1.data.elevation\n      ? token2.data.elevation - token1.data.elevation\n      : token1.data.elevation - token2.data.elevation;\n\n    return Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n  }else{\n    return distance;\n  }\n}\n\n\nfunction distanceMeasure(p0,p1){\n\tconst gs = canvas.dimensions.size;\n        const ray = new Ray(p0, p1);\n        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n        const nx = (Math.abs(ray.dx / gs));\n        const ny = (Math.abs(ray.dy / gs));\n\n        // Get the number of straight and diagonal moves\n        const nDiagonal = Math.min(nx, ny);\n        const nStraight = Math.abs(ny - nx);\n\n        // Diagonals in PF pretty much count as 1.5 times a straight\n        var distance = Math.floor(nDiagonal * 1.5 + nStraight);\n\treturn distance\n}\n\n//Account for token size.\nfunction measureDistancePF2(p0, p1){\n       const gs = canvas.dimensions.size;\n       Cp0x = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.x : 100*Math.floor(p0.x/100)+50;\n       Cp0y = (Math.floor(p0.hitArea.width/gs) >= 1|| Math.floor(p0.hitArea.height/gs) >= 1) ? p0.center.y : 100*Math.floor(p0.y/100)+50;\n       Cp1x = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.x : 100*Math.floor(p1.x/100)+50;\n       Cp1y = (Math.floor(p1.hitArea.width/gs) >= 1|| Math.floor(p1.hitArea.height/gs) >= 1) ? p1.center.y : 100*Math.floor(p1.y/100)+50;\n\t   const prelimDistance =  distanceMeasure({x:Cp0x,y:Cp0y},{x:Cp1x,y:Cp1y});\n\t\tlet distance = prelimDistance;\n\tif(p0 === p1){distance = 0;\n    }else {\n\t\t\t   const diffX0 = Cp0x - Cp1x\n\t\t\t   const diffY0 = Cp0y - Cp1y\n\t\t\t   const diffX01 = Cp1x - (Cp0x-Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2))\n\t\t\t   const diffY01 = Cp1y - (Cp0y-Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))\n\t\t\t   const testF = distanceMeasure({x:Cp0x-(Math.sign(diffX0)*((p0.hitArea.width/2)-gs/2)),y:Cp0y-(Math.sign(diffY0)*((p0.hitArea.height/2)-gs/2))},{x:Cp1x-(Math.sign(diffX01)*((p1.hitArea.width/2)-gs/2)),y:Cp1y-(Math.sign(diffY01)*((p1.hitArea.height/2)-gs/2))})\n\t\t\t   distance = testF;\n\t\t\t };\n\n\t\t//Finalize things\n\t\tconst distanceOnGrid = distance * canvas.dimensions.distance;\n        return distanceOnGrid;\n    }",
              "icon": "fa-ruler",
              "isFunction": true,
              "expression": false,
              "isNumber": false,
              "color": "#fbdf2d"
            }
          ]
        }
      ],
      "static": {
        "displayNameInTooltip": "HOSTILE",
        "useAccentEverywhere": false,
        "accentColor": "#000000",
        "tokenDispositions": [
          "OWNED",
          "FRIENDLY",
          "NEUTRAL",
          "HOSTILE"
        ],
        "useAccentColorForEverything": false
      }
    }
  }
}
